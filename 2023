# 0. 鼠鼠我啊，要被祸害了
有1000瓶水，其中有一瓶有毒，小白鼠只要尝一点带毒的水，24小时后就会准时死亡。至少要多少只小白鼠才能在24小时内鉴别出哪瓶水有毒？         
每只小白鼠有 “存活” 和 “死亡” 两种状态，可对应二进制的 “0” 和 “1”。10 只小白鼠能表示的状态组合为 pow(2,10)=1024 种，足以覆盖 1000 瓶水的编码需求（1024 ≥ 1000）。                          
---
# 1. 先预测一下~

按照函数要求输入自己的姓名试试~     
    
char *welcome() {      
    // 请你返回自己的姓名              
    return zym;            
}          
int main(void) {             
    char *a = welcome();              
    printf("Hi, 我相信 %s 可以面试成功!\n", a);                
    return 0;                
}            

---
# 2. 欢迎来到Linux兴趣小组

有趣的输出，为什么会这样子呢~

int main(void) {                 
    char *ptr0 = "Welcome to Xiyou Linux!";//字符串字面量存在只读区                 
    char ptr1[] = "Welcome to Xiyou Linux!";//数组初始化会复制到栈区                  
    if (*ptr0 == *ptr1) {                       
      printf("%d\n", printf("Hello, Linux Group - 2%d", printf("")));//*ptr0 是字符串第一个字符 'W'（ASCII 87），*ptr1 也是数组第一个字符 'W'，因此条件成立，执行内部代码。打印Hello, Linux Group - 2023                                  
    }                 
    int diff = ptr0 - ptr1;//导致 ptr0 和 ptr1 指向不同内存（即使内容相同）。                           
    printf("Pointer Difference: %d\n", diff);不同区域的指针相减结果非 0                         
}           

---
# 3. 一切都翻倍了吗

    请尝试解释一下程序的输出。               
    请谈谈对sizeof()和strlen()的理解吧。    
    什么是sprintf()，它的参数以及返回值又是什么呢？              
    sprintf 是 C 语言标准库中用于格式化字符串的函数，其核心功能是将数据按指定格式写入字符数组，返回值为实际写入的字符数。（若读取失败，则返回值为-1.）          
    参数：        
        str：目标字符数组，用于存储格式化后的结果（需确保数组大小足够，避免溢出）。                 
        format：格式控制字符串（与 printf 规则一致，支持 %d、%s、%f 等占位符）。       
        ...：可变参数，即需要格式化的数据（如整数、字符串、浮点数等）。          
int main(void) {                                 
    char arr[] = {'L', 'i', 'n', 'u', 'x', '\0', '!'}, str[20];                   
    short num = 520;                                            
    int num2 = 1314;                                 
    printf("%zu\t%zu\t%zu\n", sizeof(*&arr), sizeof(arr + 0),                                                 
           sizeof(num = num2 + 4));                                     
    printf("%d\n", sprintf(str, "0x%x", num) == num);                     
    printf("%zu\t%zu\n", strlen(&str[0] + 1), strlen(arr + 0));                                            
}    
    格式化num（520）为十六进制字符串，%x输出小写十六进制，520 的十六进制为208，故str被写入"0x208"。                   
    sprintf的返回值是写入的字符数（不含\0），"0x208"共 5 个字符，故返回5。                  
    比较5 == num：num的值是 520，5≠520，故条件为假，输出 0。                       
                 
    &str[0]是str首元素地址（char*），+1指向第二个元素（str[1]）。                     
    str的内容是"0x208"，从str[1]开始的字符串是"x208"，长度为 4（不含\0），故结果为 4。                         
 ---
 # 4. 奇怪的输出

程序的输出结果是什么？解释一下为什么出现该结果吧~                   
a=64 b=63 c=-1 ch=128                
int main(void) {                       
    char a = 64 & 127;                   
    char b = 64 ^ 127;                     
    char c = -64 >> 6;              
    char ch = a + b - c;                     
    printf("a = %d b = %d c = %d\n", a, b, c);                      
    printf("ch = %d\n", ch);                
}                                

位运算的操作对象是 整数类型（包括有符号和无符号整数），本质是对整数在内存中存储的 二进制补码（补码） 进行逐位操作。                                
正数的补码 = 原码 负数的补码 = 其绝对值的原码 按位取反 后 加 1                   
    负数 -64 的补码 = 正数取反 + 1：                                 
    取反：11111111 11111111 11111111 10111111                      
    +1 后：11111111 11111111 11111111 11000000                
右移 6 位后：                       
高 6 位补符号位（1），原高 32-6=26 位右移 6 位，低 6 位被移出，结果为：                   
11111111 11111111 11111111 11111111                 
补码规则：全 1 表示 -1         
---
# 5. 乍一看就不想看的函数
      
“人们常说互联网凛冬已至，要提高自己的竞争力，可我怎么卷都卷不过别人，只好用一些奇技淫巧让我的代码变得高深莫测。”                   

这个func()函数的功能是什么？是如何实现的？                     

int func(int a, int b) {                                            
    if (!a) return b;     //当a为0时，返回b;           
    return func((a & b) << 1, a ^ b);  第一次递归调用为（18,0）            
}
int main(void) {             
    int a = 4, b = 9, c = -7;              
    printf("%d\n", func(a, func(b, c))); //fun(4,fun(9,-7))=6              
}    
位运算(补码的运算)          
a^b:a,b二进制数不同则为1       
a&b:a,b二进制数全为1则为1；         
 <<1:向左移动1位             
 >>1:向右移动1位         
递归调用函数，直到函数中的a为0时返回6；       

# 6. 自定义过滤

请实现filter()函数：过滤满足条件的数组元素。

提示：使用函数指针作为函数参数并且你需要为新数组分配空间。

typedef int (*Predicate)(int);
int *filter(int *array, int length, Predicate predicate,
            int *resultLength); /*补全函数*/
            {
             if (array == NULL || predicate == NULL || resultLength == NULL || length < 0) {
              if (resultLength != NULL) {  
             *resultLength = 0;
               return NULL;
                                          }
            *resultLength=0;
           for(int i=0;i<length;i++)
            {if(Predicate(array[i]))
            (*resultLength)++;
            }
            int *result=(int *)malloc(*resultLength*sizeof(int));
            if(result==NULL)
            {*resultLength=0;
            return NULL;  
            }
            int a=0;
            for(int i=0;i<length;i++)
            {if(predicate(array[i]))
            result[a++]=array[i];
            }
            free(
            return result;
            }
int isPositive(int num) { return num > 0; }
int main(void) {
    int array[] = {-3, -2, -1, 0, 1, 2, 3, 4, 5, 6};
    int length = sizeof(array) / sizeof(array[0]);
    int resultLength;
    int *filteredNumbers = filter(array, length, isPositive,
                                  &resultLength);
    for (int i = 0; i < resultLength; i++) {
      printf("%d ", filteredNumbers[i]);
    }
    printf("\n");
    free(filteredNumbers);
    return 0;
}

# 7. 静…态…

    如何理解关键字static？        
    使局部变量的生命周期与程序一致（而非随代码块结束销毁）。                   
    static与变量结合后有什么作用？                
    修饰局部变量（函数内的变量）                               

    生命周期改变：默认局部变量在函数调用结束后销毁（栈上分配），static 局部变量在程序启动时初始化，直到程序结束才销毁（存储在静态数区）。                                
    初始化特性：仅在第一次进入函数时初始化（默认初始化为 0），后续调用不再重新初始化。        
    作用域不变：仍仅在当前函数内可见。    
    
    . 修饰全局变量（函数外的变量）    

    作用域限制：默认全局变量可在整个程序的所有文件中访问（通过 extern 声明），static 全局变量仅在当前文件内可见，其他文件无法访问或重定义。     
    生命周期不变：仍与程序生命周期一致（静态数据区）。    
    避免命名冲突：多个文件可定义同名的 static 全局变量，互不干扰。     


    static与函数结合后有什么作用？       

    作用域限制：默认函数具有全局链接属性（可被其他文件通过 extern 声明调用），static 函数仅在当前文件内可见，其他文件无法调用。      
    避免命名冲突：多个文件可定义同名的 static 函数，互不干扰（常用于实现文件内部的辅助函数）。       


    static与指针结合后有什么作用？     
    static 与指针结合时，修饰的是指针指向的变量或指针本身       
    表示指针 p 可以指向一个 static int 类型的变量             
    static int *p; 表示指针 p 本身是静态的            
    static如何影响内存分配？                
    static 修饰的变量存储在静态数据区（而非栈或堆）            
    局部变量：栈区（生命周期随函数调用）。               
    动态分配变量（malloc）：堆区（生命周期由 free 控制）。                
    全局变量（非 static）：静态数据区（生命周期与程序一致，但作用域全局）    
# 8. 救命！指针！     

数组指针是什么？指针数组是什么？函数指针呢？用自己的话说出来更好哦，下面数据类型的含义都是什么呢？                 
数组指针：一个指向数组的指针 指针数组：一个存储指针的数组 函数指针：一个指向函数的指针                   
int (*p)[10];//数组指针                   
const int* p[10];//指针数组                       
int (*f1(int))(int*, int);f1是一个接受参数为int类型，返回一个指向接受值为int *类型和int 类型的函数的函数指针，返回值为int 类型的函数声明                    
---
# 9. 咋不循环了

程序直接运行，输出的内容是什么意思？                     
 i=0,j=1,k=2                
int main(int argc, char* argv[]) {                    
    printf("[%d]\n", argc);//argc的初始值为1 打印[1]                  
    while (argc) {//直到argc的值为0时跳出循环                      
      ++argc;                                      
    }                    
    int i = -1, j = argc, k = 1;               
    i++ && j++ || k++;//i=0&&j=0为假，i=0,j=1;k++=2                 
    printf("i = %d, j = %d, k = %d\n", i, j,k);i=0,j=1,k=2                        
    return EXIT_SUCCESS;          
}               

# 10. 到底是不是TWO

#define CAL(a) a * a * a               
#define MAGIC_CAL(a, b) CAL(a) + CAL(b)             
int main(void) {               
  int nums = 1;              
  if(16 / CAL(2) == 2) {//16/2*2*2！=2 所以if语句不执行                  
    printf("I'm TWO(ﾉ>ω<)ﾉ\n");       
  } else {           
    int nums = MAGIC_CAL(++nums, 2);nums多次自增导致为未定义行为，该操作无效                 
  }              
  printf("%d\n", nums);nums=1                
}     

# 11. 克隆困境

试着运行一下程序，为什么会出现这样的结果？         

直接将s2赋值给s1会出现哪些问题，应该如何解决？请写出相应代码。                      
出现了浅拷贝，应使用深拷贝          
浅拷贝（Shallow Copy）                    
    定义：只复制对象本身（基本类型字段直接复制），但对于对象内部的引用类型字段（如数组、其他对象等），仅复制其引用地址，而非引用指向的实际数据。     
    特点：              
        新对象和原对象的引用类型字段共享同一块内存。          
        若修改新对象的引用类型字段，原对象的对应字段会被同步修改（因为指向同一内存）。               
 深拷贝（Deep Copy）        
    定义：不仅复制对象本身，还会递归复制对象内部所有引用类型字段指向的实际数据，生成完全独立的新对象。                 
    特点：        
        新对象和原对象完全独立，各自的引用类型字段指向不同的内存。              
        修改新对象的任何字段，都不会影响原对象。       
在原有代码上加入深拷贝函数        
void deepcopy(struct Student *dest, const struct Student *src)       
{if(dest->name!=NULL)        
{free(dest->name);          
dest->name=NULL;          
}         
dest->name=(char*)malloc(strlen(dest->name)+1);   
strcpy(dest->name,src->name);        
dest->age=src->age;          
}          
struct Student {//定义student结构体                  
    char *name;                 
    int age;                        
};                      

void initializeStudent(struct Student *student, const char *name,                   
                       int age) {                   
    student->name = (char *)malloc(strlen(name) + 1);//动态分配name的内存                            
    strcpy(student->name, name);//复制name到结构体中            
    student->age = age;                  
}                 
int main(void) {            
    struct Student s1, s2;                     
    initializeStudent(&s1, "Tom", 18);                   
    initializeStudent(&s2, "Jerry", 28);                 
    s1 = s2;//拷贝s2的内容到s1中，s1->name与s2->name指向内容一致，复制指针值，而非字符串内容。s1->age=s2->age                     
    printf("s1的姓名: %s 年龄: %d\n", s1.name, s1.age);                  
    printf("s2的姓名: %s 年龄: %d\n", s2.name, s2.age);                  
    free(s1.name);                    
    free(s2.name);//重复释放相同的内存，出现报错    
    return 0;           
}             
strcpy 是 C 语言中常用的字符串复制函数，定义在头文件 <string.h> 中。               
它的作用是将源字符串（包括末尾的 \0）复制到目标字符串中。  
---         

# 12. 你好，我是内存              
                    
作为一名合格的C-Coder，一定对内存很敏感吧~来尝试理解这个程序吧！                       

struct structure {                              
    int foo;                
    union {                        
      int integer;                 
      char string[11];                  
      void *pointer;                        
    } node;                      
    short bar;                
    long long baz;                 
    int array[7];            
};             
int main(void) {                  
    int arr[] = {0x590ff23c, 0x2fbc5a4d, 0x636c6557, 0x20656d6f,                  
                 0x58206f74, 0x20545055, 0x6577202c, 0x6d6f636c,                
                 0x6f742065, 0x79695820, 0x4c20756f, 0x78756e69,                
                 0x6f724720, 0x5b207075, 0x33323032, 0x7825005d,             
                 0x636c6557, 0x64fd6d1d};            
    printf("%s\n", ((struct structure *)arr)->node.string);              
}                   
联合体的string成员只是 “起始指针”，实际字符串数据存储在联合体之后的内存中，利用了结构体整体的内存连续性。            
0x636c6557：十六进制，分为四个字节：‘0x63','0x6c','0x65','0x57'转化为‘c','l','e','W',因为是小端序，所以是反转读取。       
直到读到'0x00',即'\0'时,停止读取。           
最后打印 Welcome to XUPT , welcome to Xiyou Linux Group [2023]              

