# 0. 拼命的企鹅

一只企鹅在爬山，每隔一段路都会遇到一块石头。第 1 块石头重量是 a，每往上走一段路，石头重量就会变成上一段的平方。企鹅可以选择把某些石头捡起来，最后把捡到的石头重量相乘。

它怎样捡石头，才能得到重量乘积恰好是 a 的 b 次方的石头？（比如 b = 173 时， 要捡哪些石头？）
将指数b转化成二进制数，1+4+8+32+128=173                   
---

# 1. 西邮Linux欢迎你啊

请解释以下代码的运行结果。       
int main() {    
    if (printf("Hi guys! ") || printf("Xiyou Linux ")) {      
        printf("%d\n", printf("Welcome to Xiyou Linux 2%d", printf("")));     
    }     
    return 0;    
}     
//第二行中的第一个printf的返回值为字符数9,或语句为真；    
//首先是内部printf的返回值为0；再打印Welcome to Xiyou Linux 20,最后打印第二个printf的返回值25     
//最后打印Welcome to Xiyou Linux 2025      
---
# 2. 可以和 \0 组一辈子字符串吗？    

你能找到成功打印的语句吗？你能看出每个 if 中函数的返回值吗？这些函数各有什么特点？    
sizeof 是 C/C++ 中的一个编译时运算符（不是函数），用于计算变量、数据类型或表达式结果在内存中占用的字节数。
其工作原理与编译过程紧密相关，核心是 “在编译阶段确定大小，不执行表达式”。
strlen 的核心工作原理是：运行时从字符串起始地址遍历，以 '\0' 为终止标志，计数有效字符个数（不含 '\0'）。
使用时必须确保字符串以 '\0' 结尾，否则会出现未定义行为；
int main() {      
    char p1[] = { 'W', 'e', 'l', 'c', 'o', 'm', 'e', '\0' };    
    char p2[] = "Join us\0", p4[] = "xiyou_linux_group";     
    const char* p3 = "Xiyou Linux Group\0\n2025\0";     
    if (strcmp(p1, p2)) {    
        printf("%s to %s!\n", p1, p2);    
    }    
    if (strlen(p3) > sizeof(p3)) {    
        printf("%s", p3);     
    }    
    if (sizeof(p1) == sizeof(p2)) {      
        printf("%s", p4);     
    }    
    return 0;    
}     
//strcmp 是 C 语言标准库（string.h）中的字符串比较函数，用于比较两个字符串的大小，核心依据是字符的 ASCII 码值。    
//    
    返回值 > 0：s1 大于 s2（第一个不同字符的 ASCII 码：s1[i] > s2[i]）。   
    返回值 = 0：s1 等于 s2（所有字符相同，长度也相同）。    
    返回值 < 0：s1 小于 s2（第一个不同字符的 ASCII 码：s1[i] < s2[i]）。   
因为p1和p2不同，且‘w'的ASCII 码值大于‘j'的 ASCII 码值,所以strcmp(p1, p2)的返回值大于0,if表达式为真，打印welcome to join us;   
strlen(p3)为17,sizeof(p3)为8,所以strlen(p3)>sizeof(p3),if的表达式为真，打印Xiyou Linux Group    
因为sizeof(p1)为8,sizeof(p2)为9,所以if语句不执行；    
---
# 3. 数学没问题，浮点数有鬼

这个程序的输出是什么？解释为什么会这样？    

int main() {    
    float a1 = 0.3, b1 = 6e-1, sum1 = 0.9;     
    printf("a1 + b1 %s sum1\n", (a1 + b1 == sum1) ? "==" : "!=");//浮点数进制转化导致精度损失，以至于0.3+0.6！=0.9   
    float a2 = 0x0.3p0, b2 = 0x6p-4, sum2 = 0x0.9p0;//十六进制是二进制的直观表示形式  ，精度没有丢失   
    printf("a2 + b2 %s sum2\n", (a2 + b2 == sum2) ? "==" : "!=");     
    return 0;     
}    
---
# 4. 不合群的数字

在一个数组中，所有数字都出现了偶数次，只有两个数字出现了奇数次，请聪明的你帮我看看以下的代码是如何找到这两个数字的呢？

void findUndercoverIDs(int nums[], int size) {       
    int xorAll = 0,id_a = 0,id_b = 0;      
    for (int i = 0; i < size; i++) {//遍历全部数字，异或结果为两个不同的数字      
        xorAll ^= nums[i];     
    }     
    int diffBit = xorAll & -xorAll;//通过与运算找到两数不同的最低位     
    for (int i = 0; i < size; i++) {      
        if(nums[i] & diffBit){//将数组分组      
            id_a ^= nums[i];      
        } else {      
            id_b ^= nums[i];//通过最低位来分开两个不同的数字     
        }      
    }      
    printf("These nums are %d %d\n", id_a, id_b);     
}     
//^	按位异或	对应位不同则为 1，相同则为 0（0^a=a）    
//&	按位与	对应位都为 1 则为 1，否则为 0     
---
# 5. 会一直循环吗？

你了解 argc 和 argv 吗，程序的输出是什么？为什么会这样？     

    argc（argument count）：命令行参数的总数量（包含程序名本身），类型为 int，最小值为 1（至少包含程序名）。    
    argv（argument vector）：存储命令行参数的字符串数组，argv[0] 是程序名，argv[1] 及以后是用户输入的参数。    
  
int main(int argc, char* argv[]) {     
    printf("argc = %d\n", argc);//打印初始值     
    while (argc++ > 0) {//argc自加      
        if(argc < 0){//直到整型溢出为负数      
            printf("argv[0] %s\n", argv[0]);打印程序名      
            break;     
        }     
    }     
    printf("argc = %d\n", argc);打印溢出值     
    return 0;    
}      
# 6. const 与指针：谁能动，谁不能动？

struct P {       
    int x;       
    const int y;      
};//y被const修饰，不可修改        
    
int main() {       
    struct P p1 = { 10, 20 }, p2 = { 30, 40 };      
    const struct P p3 = { 50, 60 };      
    struct P* const ptr1 = &p1;//ptr1的const在*左边，所以ptr1的指向不能改，但内容可改       
    const struct P* ptr2 = &p2;//ptr2的const在*右边，所以ptr2的指向能改，但内容不可改        
    const struct P* const ptr3 = &p3;//ptr3的*左右都被const修饰，所以ptr3的指向和内容都不可改       
    return 0;       
}        
const 修饰的对象遵循 “左数右指” 原则：     
     
    const 在 * 左边：修饰指针指向的内容（内容不能改）。     
    const 在 * 右边：修饰指针本身（指针的指向不能改）。      
---
# 7. 指针！数组!

在主函数中定义如下变量:    
     
int main() {    
    int a[3] = { 2, 4, 8 };    
    int(*b)[3] = &a;    
    int* c[3] = { a, a + 1, a + 2 };    
    int (*f1(int))(int*, int);    
    return 0;    
}     
a:数组首元素的地址, *b：数组a *b + 1：a[1], b:数组指针，指向a数组, b + 1：在b的基础上在往后走一个a数组的步长, * (*b + 1)：4, c, sizeof(a)：12, sizeof(b)：8, sizeof(&a)：12, sizeof(f1)：1 c:24       
---

# 8. 全局还是局部！！！   
    
观察程序输出，思考为什么？
     
int g;//全局变量 g：定义时未初始化，默认值为 0            
int func() {                 
    static int j = 98;//static 修饰使其生命周期与程序一致（仅初始化一次），初始值为 98。每次调用 func() 时，j 会累加 g 的值。                    
    j += g;                     
    return j;                       
}                        
                    
int main() {                  
    g += 3;//g=3                
    char arr[6] = {};               
    arr[1] = func();//第一次调用，此时j=101,'e'                
    arr[0] = func();//第二次调用，此时j=104,'h'                      
    arr[2] = arr[3] = func() + 1;//第三次调用，此时j=107,107+1=108,'l'               
    arr[4] = func() + 1;//第四次调用，此时j=111,'o'                   
    printf("%s linux\n",arr);//打印hello linux                    
    return 0;                      
}                 
# 9. 宏函数指针             

观察程序结果，说说程序运行的过程：                     

#define CALL_MAIN(main, x) (*(int (*)(int))*main)(x); //通过函数指针数组 main（实际是 registry），调用存储在数组中的函数（即 main 自身）。拆解替换逻辑
#define DOUBLE(x) 2 * x
int (*registry[1])(int);//一个能装下 1 个函数指针的数组
int main(int argc) {
    if (argc > 2e3) return 0;
    printf("%d ", argc + 1);打印2,4,8,16,32,64,128,256,512,1024
    *registry = (int(*)(int))main；//将main函数的地址存入registry数组中
    CALL_MAIN(registry, DOUBLE(argc + 1));//*registry=registry[0],(int (*)(int))强制类型转化为接收类型为int,返回类型为int的函数指针，即main(DOUBLE(argc + 1)),递归调用main函数
     return 0;
}

# 10. 拼接 排序 去重

本题要求你编写以下函数，不能改动 main 函数里的代码。实现对 arr1 和 arr2 的拼接、排序和去重。你需要自行定义 result 结构体并使用 malloc 手动开辟内存。

int main() {
    int arr1[] = { 6, 1, 2, 1, 9, 1, 3, 2, 6, 2 };
    int arr2[] = { 4, 2, 2, 1, 6, 2 };
    int len1 = sizeof(arr1) / sizeof(arr1[0]);
    int len2 = sizeof(arr2) / sizeof(arr2[0]);

    struct result result;
    your_concat(arr1, len1, arr2, len2, result);
    print_result(result);
    your_sort(result);
    print_result(result);
    your_dedup(result);
    print_result(result);
    free(result.arr);
    return 0;
}
struct result
{int *arr;
int len;
}
void your_concat(int arr1[],int len1,int arr2[],int len2,struct result *result)
{result->len=len1+len2;
result->arr=(int *)malloc(sizeof(int)*len);
    if(result->arr==NULL)
        {result->len=0;
        return 0;}
for(int i=0;i<len1;i++)
{arr[i]=arr1[i];}
for(int j=0;j<len2;j++)
{arr[len1+j]=arr2[j]；}
void your_sort(struct result *result)
{for(int i=0;i<result->len;i++)
    {for(int j=i+1;j<result->len;j++)
        {if(arr[i]>arr[j])
            {int temp=arr[i];
            arr[i]=arr[j];
            arr[j]=temp;}
         }
    }
}
void your_dedup(struct result *result)
{if (result->len <= 1 || result->arr == NULL) 
        {return 0; }
int *arr = result->arr;
int a=0;
for(int i=0;i<result->len-1;i++)
 {   if(arr[i]!=arr[i+1])
    {arr[a++]=arr[i]}
}
arr[a++] = arr[result->len - 1];
result->len = a;
 int *temp = (int*)realloc(arr, a * sizeof(int));
 if (temp != NULL) {
 result->arr = temp;
    }
}




# 11. 指针魔法
     
用你智慧的眼睛，透过这指针魔法的表象，看清其本质：     
     
void magic(int(*pa)[6], int** pp) {             
    **pp += (*pa)[2];//**pp=**pp+a[2]=10                 
    *pp = (*pa) + 5;// **pp指向a[5]           
    **pp -= (*pa)[0];// **pp=**pp-a[0]=10=a[5]              
    *pp = (*pa) + ((*(*pa + 3) & 1) ? 3 : 1);// a[3]=8&1=0,**pp=a[1]               
    *(*pp) += *(*pp - 1);// **pp=**pp+a[0]=10+2=12=a[1]                
    *pp = (*pa) + 2;// **pp指向a[2],p也指向a[2]                
}           
int main() {               
    int a[6] = { 2, 4, 6, 8, 10, 12 };               
    int* p = a + 1,** pp = &p;//*p指向a[1],**pp指向*p               
    magic(&a, pp);                
    printf("%d %d\n%d %d %d\n%d %d\n",*p,**pp,a[1],a[2],a[3],a[5],p-a);//    p - a：p指向a[2]，与a的首地址偏移 2，结果为 2。             
    return 0;          
}           
---
# 12. 奇怪的循环

你能看明白这个程序怎样运行吗？试着理解这个程序吧！

union data {
    void**** p;
    char arr[20];
};
typedef struct node {
    int a;
    union data b;
    void (*use)(struct node* n);//函数
    char string[0];
} Node;
void func2(Node* node);

void func1(Node* node) {
    node->use = func2;
    printf("%s\n", node->string);
}
void func2(Node* node) {
    node->use = func1;
    printf("%d\n", ++(node->a));
}
int main() {
    const char* s = "Your journey begins here!";
    Node* P = (Node*)malloc(sizeof(Node) + (strlen(s) + 1) * sizeof(char));
    strcpy(P->string, s);
    P->use = func1;
    P->a = sizeof(Node) * 50 + sizeof(union data);
    while (P->a < 2028) {
        P->use(P);
    }
    free(P);
    return 0;
}
sizeof(Node)=8+24+8=40;所以P->a的初始值为40*50+24=2024；
再递归调用fun1,fun2;
直到P->a自增为2028时，跳出循环
最终打印Your journey begins here!
2025
Your journey begins here!
2026
Your journey begins here!
2027
Your journey begins here!
2028



