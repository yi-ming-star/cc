# 0. 聪明的吗喽

一个小猴子边上有 100 根香蕉，它要走过 50 米才能到家，每次它最多搬 50 根香蕉，（多了就拿不动了），它每走 1 米就要吃掉一根，请问它最多能把多少根香蕉搬到家里。

（提示：他可以把香蕉放下往返走，但是必须保证它每走一米都能有香蕉吃。也可以走到 n 米时，放下一些香蕉，拿着 n 根香蕉走回去重新搬 50 根。）
临界点：走多少米之后可以直接把香蕉带回去     
设往回走x米 那么此时在走回去后香蕉数量为100-3x;     
而剩下的香蕉要一次带回，所以50-x<=100-3x<=50;    
解得到16.67<=x<=25;    
所以最多为49-33=16；    
--- 
# 1. 西邮Linux欢迎你啊

请解释以下代码的运行结果。
 #include<stdio.h>   
int main() {   
    unsigned int a = 2024;//初始化    
    for (; a >= 0; a--)//因为unsigned int>=0,所以该循环为死循环    
        printf("%d\n", printf("Hi guys! Join Linux - 2%d", printf("")));//先打印0,再打印Hi guys! Join Linux - 20,最后因为的二个printf的返回值为23,打印23；   
    return 0;   
}  


---
# 2. 眼见不一定为实

输出为什么和想象中不太一样？  

你了解 sizeof() 和 strlen() 吗？他们的区别是什么？   
sizeof是运算符，计算变量 / 类型占用的内存字节数，包含字符串末尾的 '\0'（如果是字符串变量），适用任意变量 / 类型（数组、指针、基本类型等）；   
strlen是库函数，计算字符串中 '\0' 之前的字符数（不包含 '\0'）遇到第一个 '\0' 就停止，不包含 '\0' 仅适用于以 '\0' 结尾的字符串（字符数组或字符串常量）。    

int main() {   
    char p0[] = "I love Linux";sizeof(p0)：数组总字节数 = 13（包含自动添加的 '\0'）。 strlen(p0)：'\0' 前的字符数 = 12。   
    const char *p1 = "I love Linux\0Group";sizeof(p1)：指针变量的大小 第一个 '\0'  strlen(p1)：前的字符数 = 12（和 p0 相同）   
    char p2[] = "I love Linux\0";初始化字符串包含显式 '\0'，编译器会在末尾再自动添加一个 '\0'（但字符串函数只认第一个 '\0'）。     
    printf("%d\n%d\n", strcmp(p0, p1), strcmp(p0, p2));p0,p1,p2的有效内容为"I love Linux"，所以strcmp的返回值为0；    
    printf("%d\n%d\n", sizeof(p0) == sizeof(p1), strlen(p0) == strlen(p1));sizeof(p0) == sizeof(p1)显然不相等 → 返回 0。 strlen(p0) == strlen(p1)：两者的有效字符串长度都是 12，相等 → 返回 1。     
    return 0;  
}  
--- 
# 3. 1.1 - 1.0 != 0.1

为什么会这样，除了下面给出的一种方法，还有什么方法可以避免这个问题？   
使用分数表示（精确计算）     
将浮点数转换为 “分子 / 分母” 的分数形式，通过整数运算比较（适用于能明确表示为分数的场景）。       
int main() {    //浮点数误差的本质是 “二进制无法精确表示所有十进制小数”      
    float a = 1.0, b = 1.1, ex = 0.1;     
    printf("b - a == ex is %s\n", (b - a == ex) ? "true" : "false");    
    int A = a * 10, B = b * 10, EX = ex * 10;//放大为整数来比较       
    printf("B - A == EX is %s\n", (B - A == EX) ? "true" : "false");       
}   
---
# 4. 听说爱用位运算的人技术都不太差

解释函数的原理，并分析使用位运算求平均值的优缺点。      
该函数通过递归分治将数组不断二分，直到单个元素，再逐层用位运算求平均合并结果，最终得到整个区间的平均值。       
位运算(a&b) + ((a^b)>>1)是对(a+b)/2的等价实现，利用二进制特性避免了除法运算，在底层实现上更高效。    
函数返回的是整数平均值（向下取整），且仅适用于整数数组。    
int average(int nums[], int start, int end) {    
    if (start == end)       
        return nums[start];      
    int mid = (start + end) / 2;          
    int leftAvg = average(nums, start, mid);         
    int rightAvg = average(nums, mid + 1, end);            
    return (leftAvg & rightAvg) + ((leftAvg ^ rightAvg) >> 1);              
}          
---
# 5. 全局还是局部!!!

先思考输出是什么，再动动小手运行下代码，看跟自己想得结果一样不一样 >-<

int i = 1;//全局变量i，作用域为整个程序               
static int j = 15;//静态全局变量j，作用域为整个程序    
int func() {      
    int i = 10;//局部变量i，作用域仅在func()内部，会覆盖全局变量i。           
    if (i > 5) i++;       
    printf("i = %d, j = %d\n", i, j);      
    return i % j;//返回11 % 15 = 11     
}     
int main() {     
    int a = func();    
    printf("a = %d\n", a);     
    printf("i = %d, j = %d\n", i, j);//此处访问的是全局变量i=1和全局j=15。    
    return 0;     
}     
# 6. 指针的修罗场：改还是不改，这是个问题

指出以下代码中存在的问题，并帮粗心的学长改正问题。

int main(int argc, char **argv) {    
    int a = 1, b = 2;//初始化     
    const int *p = &a;p指向a且a的内容不可变     
    int * const q = &b;q 指向b且指针内容不可变     
    *p = 3, q = &a;    
    const int * const r = &a;    
    *r = 4, r = &b;//r的内容不可更改     
    return 0;    
}    
# 7.物极必反？

你了解 argc 和 argv 吗，这个程序里的 argc 和 argv 是什么？     
argc：命令行参数的数量（包含程序名本身，至少为 1）。    
argv：字符串数组，存储命令行参数，argv[0]是程序名，argv[argc]固定为NULL（参数列表结束标志）。     

程序输出是什么？解释一下为什么。

int main(int argc, char *argv[]) {      
    while (argc++ > 0);//此时初始argc=3，argv[0]="./test"，argv[1]="a"，argv[2]="b"，argv[3]=NULL）。 当argc递增到INT_MAX（整数最大值）后，再自增会发生整数溢出    
    int a = 1, b = argc, c = 0;     
    if (--a || b++ && c--)//a先自减为0（表达式值为0，即假） 先取b的当前值（负数，非 0 即真），然后b自增 1 先取c的当前值（0，即假），然后c自减为-1 结果为假，因此if内的for循环不会执行        
        for (int i = 0; argv[i] != NULL; i++)    
            printf("argv[%d] = %s\n", i, argv[i]);     
    printf("a = %d, b = %d, c = %d\n", a, b, c);     
    return 0;        
}   
# 8. 指针？数组？数组指针？指针数组？

在主函数中定义如下变量：

int main() {                                                                                               
    int a[2] = {4, 8};
    int(*b)[2] = &a;
    int *c[2] = {a, a + 1};
    return 0;
}

说说这些输出分别是什么？

a, a + 1, &a, &a + 1, *(a + 1), sizeof(a), sizeof(&a)
*b, *b + 1, b, b + 1, *(*b + 1), sizeof(*b), sizeof(b)
c, c + 1, &c, &c + 1, **(c + 1), sizeof(c), sizeof(&c)  
指针？数组？数组指针？指针数组？        
a:数组a或a[0] ；a+1:a[1] ; &a:数组a的地址，和a[0]的地址一致 &a+1 :&a的地址加八个字节的步长  *(a+1):对a[1]解引用，得到8 sizeeof(a):4*2=8  sizeof(&a):数组指针，得到8              
*b:对b解引用，等于a数组 *b+1:a[0]的地址加一个int类型的步长 b:数组指针，指向a数组 b+1:偏移一个a数组的步长 *(*b+1):对a[1]解引用  sizeof(*b)：数组a的大小 sizeof(b)：指针在64位机中大小为8                   
c：指针数组, c + 1：c[1], &c:指针数组整体的地址 , &c + 1:偏移一个c的步长，8*2=16, **(c + 1)：a[1]=8, sizeof(c):8*2=16, sizeof(&c) :指针数组指针 8     
 


# 9. 嘻嘻哈哈，好玩好玩

在宏的魔法下，数字与文字交织，猜猜结果是什么？    
  
#define SQUARE(x) x *x   
#define MAX(a, b) (a > b) ? a : b;          
#define PRINT(x) printf("嘻嘻，结果你猜对了吗，包%d滴\n", x);              
#define CONCAT(a, b) a##b          

int main() {           
    int CONCAT(x, 1) = 5;//int x1=5         
    int CONCAT(y, 2) = 3;//int y2=3            
    int max = MAX(SQUARE(x1 + 1), SQUARE(y2))//11>9?11:9=11 SQUARE(x1 + 1) → 替换为 x1 + 1 * x1 + 1（不是 (x1+1)*(x1+1)！）
代入 x1=5 → 计算：5 + 1*5 + 1 = 5+5+1=11；           
    PRINT(max)         
    return 0;           
}              
//#define CONCAT(a, b) a##b 是 “字符串连接” 宏，会把两个参数直接拼接成一个标识符。             
//#define SQUARE(x) x * x 没有加括号，展开时会按原样替换，可能破坏运算优先级。           

---
# 10. 我写的排序最快

写一个 your_sort 函数，要求不能改动 main 函数里的代码，对 arr1 和 arr2 两个数组进行升序排序并剔除相同元素，最后将排序结果放入 result 结构体中。                 

int main() {              
    int arr1[] = {2, 3, 1, 3, 2, 4, 6, 7, 9, 2, 10};            
    int arr2[] = {2, 1, 4, 3, 9, 6, 8};            
    int len1 = sizeof(arr1) / sizeof(arr1[0]);                
    int len2 = sizeof(arr2) / sizeof(arr2[0]);             

    result result;            
    your_sort(arr1, len1, arr2, len2, &result);            
    for (int i = 0; i < result.len; i++) {             
        printf("%d ", result.arr[i]);              
    }           
    free(result.arr);            
    return 0;              
}


typedef struct {           
    int* arr;           
    int len;          
} result;            
int cmp(const void* a, const void* b) {              
    return *(int*)a - *(int*)b;               
}             
void your_sort(int arr1[], int len1, int arr2[], int len2, result* res) {               
    qsort(arr1, len1, sizeof(int), cmp);            
    qsort(arr2, len2, sizeof(int), cmp);            
    int temp1[len1], cnt1 = 0;           
    for (int i = 0; i < len1; i++) {           
        if (i == 0 || arr1[i] != arr1[i-1]) {             
            temp1[cnt1++] = arr1[i];            
        }          
    }          
    int temp2[len2], cnt2 = 0;          
    for (int i = 0; i < len2; i++) {          
        if (i == 0 || arr2[i] != arr2[i-1]) {             
            temp2[cnt2++] = arr2[i];          
        }           
    }            
    int* Arr = (int*)malloc((cnt1 + cnt2) * sizeof(int));           
    int i = 0, j = 0, k = 0;      
    while (i < cnt1 && j < cnt2) {     
        if (temp1[i] < temp2[j]) {     
            Arr[k++] = temp1[i++];    
        } else if (temp1[i] > temp2[j]) {    
            Arr[k++] = temp2[j++];    
        } else {    
            Arr[k++] = temp1[i++];    
            j++;    
        }    
    }     
    while (i < cnt1) {     
        Arr[k++] = temp1[i++];     
    }     
    while (j < cnt2) {      
        Arr[k++] = temp2[j++];      
    }     
    res->arr = Arr;      
    res->len = k;      
---

# 11. 猜猜我是谁

在指针的迷宫中，五个数字化身为神秘的符号，等待被逐一揭示。          

int main() {         
    void *a[] = {(void *)1, (void *)2, (void *)3, (void *)4, (void *)5};                              
    printf("%d\n", *((char *)a + 1));//(char*)a + 1：指向 a[0] 起始地址偏移 1 字节的位置（即 a[0] 的第 2 个字节）           
    printf("%d\n", *(int *)(char *)a + 1);//(char*)a 转换为 int*：将数组首地址按 int 类型（4 字节）解析，指向 a[0] 的前 4 字节。    
    printf("%d\n", *((int *)a + 2));//(int*)a + 2：偏移 2 * 4 = 8 字节（指向 a[1] 的前 4 字节，因为 a[0] 占 8 字节）              
    printf("%lld\n", *((long long *)a + 3));//(long long*)a + 3：偏移 3 * 8 = 24 字节，指向数组第 3 个元素 a[3]（a[0]~a[2] 共 3*8=24 字节）。               
    printf("%d\n", *((short *)a + 4));//(short*)a + 4：偏移 4 * 2 = 8 字节，指向 a[1] 的前 2 字节（a[0] 占 8 字节）         
    return 0;             
}              
元素a[0]：0x0000000000000001 （8字节，值为1）           
元素a[1]：0x0000000000000002 （8字节，值为2）      
元素a[2]：0x0000000000000003 （8字节，值为3）        
元素a[3]：0x0000000000000004 （8字节，值为4）        
元素a[4]：0x0000000000000005 （8字节，值为5）           

---
# 12. 结构体变小写奇遇记

计算出 Node 结构体的大小，并解释以下代码的运行结果。

union data {         
    int a;   
    double b;         
    short c;           
};            
typedef struct node {          
    long long a;             
    union data b;          
    void (*change)( struct node *n);             
    char string[0];       
} Node;        
void func(Node *node) {           
    for (size_t i = 0; node->string[i] != '\0'; i++)           
        node->string[i] = tolower(node->string[i]);//将大写转化成小写           
}           
              
int main() {            
    const char *s = "WELCOME TO XIYOULINUX_GROUP!";            
    Node *P = (Node *)malloc(sizeof(Node) + (strlen(s) + 1) * sizeof(char));        
    strcpy(P->string, s);//将s中的内容赋给p->string          
    P->change = func;//将func的地址赋给P->change                   
    P->change(P);//P->change间接调用func函数            
    printf("%s\n", P->string);打印 welcome to xiyoulinux_group!                 
    return 0;          
}             
在 64 位系统中，结构体大小需考虑成员对齐（默认对齐方式为成员自身大小与系统字长的较小值），计算如下：           
           
    成员 long long a：占 8 字节（自身大小为 8，对齐到 8 字节边界）。              
    成员 union data b：联合体大小由最大成员决定，double b 占 8 字节，对齐到 8 字节边界（与前一成员连续，无间隙）。        
    成员 void (*change)(struct node *n)：函数指针在 64 位系统中占 8 字节，对齐到 8 字节边界（与前一成员连续，无间隙）。           
    成员 char string[0]：长度为 0 的数组（柔性数组），不占用结构体本身的空间，仅作为后续动态分配内存的起始标记。             
          
总大小：8 + 8 + 8 = 24 字节（柔性数组不占空间）。        

